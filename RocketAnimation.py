# -*- coding: utf-8 -*-
"""Trabalho 2 - Caio  Alves Fiorotti e Matheus Meier Schreiber.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1AFKnNWUHfB889hMwchoGpbSwqCKXCMjd
"""

############################## INFORMAÇÕES ########################################################
"""
Código elaborado por Caio Alves Fiorotti e Matheus Meier Schreiber,
para a disciplina de Expressão Gráfica em Engenharia, Semestre 2021/2,
na Universidade Federal do Espírito Santo (UFES).

Data da entrega: 09 de março de 2022
"""
############################################################################################################

from numpy.lib.shape_base import column_stack
import numpy as np
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D  
from matplotlib import animation, rc, rcParams

############################# FUNÇÕES TRANSFORMAÇÃO ########################################################
# Função translação
def trans3D(dx,dy,dz):
  T3D = np.array([[1, 0, 0, dx],[0, 1, 0, dy],[0, 0, 1, dz], [0, 0, 0, 1]])
  return T3D

# Função escala
def scale3D(sx,sy,sz):
  S3D = np.array([[sx, 0, 0, 0],[0, sy, 0, 0],[0, 0, sz, 0], [0, 0, 0, 1]])
  return S3D

# Função rotação
def rot3D(angle,axis):
  ang_rad = (angle/180)*np.pi
  if axis == 'z':
    R3D = np.array([[np.cos(ang_rad),-np.sin(ang_rad),0,0],[np.sin(ang_rad),np.cos(ang_rad),0,0],[0,0,1,0],[0,0,0,1]])
  elif axis == 'x':
    R3D = np.array([[1,0,0,0],[0,np.cos(ang_rad),-np.sin(ang_rad),0],[0,np.sin(ang_rad),np.cos(ang_rad),0],[0,0,0,1]])
  elif axis == 'y':
    R3D = np.array([[np.cos(ang_rad),0,np.sin(ang_rad),0],[0,1,0,0],[-np.sin(ang_rad),0,np.cos(ang_rad),0],[0,0,0,1]])
  else:
    R3D = np.eye(4,4)
  return R3D



############################# CLASSES DOS OBJETOS ########################################################
class Foguete():
  def __init__(self, pontos = [], centro = [], base = [], ponta = [], basePonta = [], baseCentro=[]):
    self.pontos = pontos
    self.centro = centro
    self.base = base
    self.ponta = ponta
    self.basePonta = basePonta
    self.baseCentro = baseCentro

class Pessoa():
  def __init__(self, pontos = [], centro = [], braco2 = [], baseBraco2 = [],
                cabeca = [], baseCabeca = []):
    self.pontos = pontos
    self.centro = centro
    self.braco2 = braco2
    self.baseBraco2 = baseBraco2
    self.cabeca = cabeca
    self.baseCabeca = baseCabeca

class Plataforma():
  def __init__(self, pontos = [], centro = []):
    self.pontos = pontos
    self.centro = centro

class Nuvem():
  def __init__(self,pontos=[], centro = []):
    self.pontos = pontos

class Paraquedas():
  def __init__(self,pontos=[], centro = []):
    self.pontos = pontos
    self.centro = centro



############################ MONTAGEM DOS PONTOS E DA FIGURA ################################################

# marcando os pontos da plataforma
plataforma = np.array([
                       [0, 0, 0],
                       [20, 0, 0],
                       [20, 20, 0],
                       [0, 20, 0],
                       [0, 0, 0],
                       [2.5, 2.5, 5],
                       [17.5, 2.5, 5],
                       [20, 0, 0],
                       [17.5, 2.5, 5],
                       [17.5, 17.5, 5],
                       [20, 20, 0],
                       [17.5, 17.5, 5],
                       [2.5, 17.5, 5],
                       [0, 20, 0],
                       [2.5, 17.5, 5],
                       [2.5, 2.5, 5]
])
# transformando os pontos da plataforma em coordenadas homogêneas
plataforma = np.transpose(plataforma) # transposta
plataforma = np.vstack([plataforma, np.ones(np.size(plataforma,1))]) # adicionando uma linha de 1s no final

centroPlat = np.array([10, 10, 2.5, 1])

# criando a plataforma com a classe
Plataforma_1 = Plataforma(plataforma, centroPlat)
Plataforma_2 = Plataforma(plataforma, centroPlat)


# marcando os pontos do foguete
foguete = np.array([
                    # primeira asa
                    [5, 5, 10],
                    [10, 5, 10],
                    [10, 5, 15],
                    [10, 2, 12],
                    [10, 2, 5],
                    [10, 5, 5],
                    [10, 5, 10],
                    [5, 5, 10],
                    # segunda asa
                    [5, 10, 10],
                    [5, 10, 15],
                    [2, 10, 12],
                    [2, 10, 5],
                    [5, 10, 5],
                    [5, 10, 10],
                    [5, 5, 10],
                    # terceira asa
                    [5, 15, 10],
                    [10, 15, 10],
                    [10, 15, 15],
                    [10, 18, 12],
                    [10, 18, 5],
                    [10, 15, 5],
                    [10, 15, 10],
                    [5, 15, 10],
                    [5, 5, 10],
                    # quarta asa
                    [5, 15, 10],
                    [15, 15, 10],
                    [15, 10, 10],
                    [15, 10, 15],
                    [18, 10, 12],
                    [18, 10, 5],
                    [15, 10, 5],
                    [15, 10, 10],
                    [15, 15, 10],
                    [5, 15, 10],
                    [5, 5, 10],
                    [15, 5, 10],
                    [15, 10, 10],
                    [15, 5, 10],
                    [5, 5, 10],
                    # corpo
                    [5, 5, 25],
                    [15, 5, 25],
                    [15, 5, 10],
                    [15, 5, 25],
                    [15, 15, 25],
                    [15, 15, 10],
                    [15, 15, 25],
                    [5, 15, 25],
                    [5, 15, 10],
                    [5, 15, 25],
                    [5, 5, 25],
                    # ponta
                    
])
# transformando os pontos do foguete em coordenadas homogêneas
foguete = np.transpose(foguete) # transposta
foguete = np.vstack([foguete, np.ones(np.size(foguete,1))]) # adicionando uma linha de 1s no final

centro = [10, 10, 20, 1]

base = np.array([
                 [5, 5, 5],
                 [15, 5, 5],
                 [15, 15, 5],
                 [5, 15, 5],
                 [5, 5, 5],
                 [5, 5, 10],
                 [15, 5, 10],
                 [15, 5, 5],
                 [15, 5, 10],
                 [15, 15, 10],
                 [15, 15, 5],
                 [15, 15, 10],
                 [5, 15, 10],
                 [5, 15, 5],
                 [5, 15, 10],
                 [5, 5, 10],
                    
])
base = np.transpose(base)
base = np.vstack([base, np.ones(np.size(base,1))])
baseCentro = np.array([10, 10, 7.5, 1])

ponta = np.array([
                  [5, 5, 25],
                  [10, 10, 35],         
                  [5, 5, 25],
                  [5, 15, 25],
                  [10, 10, 35],         
                  [5, 15, 25],
                  [15, 15, 25],
                  [10, 10, 35],         
                  [15, 15, 25],
                  [15, 5, 25],
                  [10, 10, 35],         
                  [15, 5, 25],
                  [5, 5, 25]
])
ponta = np.transpose(ponta)
ponta = np.vstack([ponta, np.ones(np.size(ponta,1))])

basePonta = np.array([5, 10, 25, 1])

# construindo o foguete com a classe
Foguete = Foguete(foguete, centro, base, ponta, basePonta, baseCentro)


# marcando os pontos da pessoa
pessoa = np.array([
                   # perna 1
                   [0, -30, 0],
                   [0, -25, 0],
                   [-5, -25, 0],
                   [-5, -30, 0],
                   [0, -30, 0],
                   [0, -30, 10],
                   [0, -25, 10],
                   [0, -25, 0],
                   [0, -25, 10],
                   [-5, -25, 10],
                   [-5, -25, 0],
                   [-5, -25, 10],
                   [-5, -30, 10],
                   [-5, -30, 0],
                   [-5, -30, 10],
                   [0, -30, 10],
                   # perna 2
                   [-10, -30, 10],
                   [-10, -25, 10],
                   [-15, -25, 10],
                   [-15, -30, 10],
                   [-10, -30, 10],
                   [-10, -30, 0],
                   [-10, -25, 0],
                   [-10, -25, 10],
                   [-10, -25, 0],
                   [-15, -25, 0],
                   [-15, -25, 10],
                   [-15, -25, 0],
                   [-15, -30, 0],
                   [-15, -30, 10],
                   [-15, -30, 0],
                   [-10, -30, 0],
                   # corpo
                   [-10, -30, 10],
                   [-15, -30, 10],
                   [-15, -25, 10],
                   [0, -25, 10],
                   [0, -30, 10],
                   [-15, -30, 10],
                   [-15, -30, 28],
                   [-15, -25, 28],
                   [-15, -25, 10],
                   [-15, -25, 28],
                   [0, -25, 28],
                   [0, -25, 10],
                   [0, -25, 28],
                   [0, -30, 28],
                   [0, -30, 10],
                   [0, -30, 28],
                   [-15, -30, 28],
                   [-15, -30, 28],
                   # braço 1
                   [-15, -29, 28],
                   [-15, -26, 28],
                   [-18, -26, 28],
                   [-18, -29, 28],
                   [-15, -29, 28],
                   [-15, -29, 13],
                   [-15, -26, 13],
                   [-15, -26, 28],
                   [-15, -26, 13],
                   [-18, -26, 13],
                   [-18, -26, 28],
                   [-18, -26, 13],
                   [-18, -29, 13],
                   [-18, -29, 28],
                   [-18, -29, 13],
                   [-15, -29, 13],
                   [-15, -29, 28],
                   [-15, -30, 28],
                   [0, -30, 28],
                   [0, -29, 28],
                   # braço 2
                   
                   [0, -30, 28],
                   # cabeça
])
pessoa = np.transpose(pessoa)
pessoa = np.vstack([pessoa, np.ones(np.size(pessoa,1))])

centroPessoa = np.array([-7.5, -27.5, 17.5, 1])

braco2 = np.array([
                   [0, -29, 28],
                   [3, -29, 28],
                   [3, -26, 28],
                   [0, -26, 28],
                   [0, -29, 28],
                   [0, -29, 13],
                   [3, -29, 13],
                   [3, -29, 28],
                   [3, -29, 13],
                   [3, -26, 13],
                   [3, -26, 28],
                   [3, -26, 13],
                   [0, -26, 13],
                   [0, -26, 28],
                   [0, -26, 13],
                   [0, -29, 13],
                   [0, -29, 28]
])
braco2 = np.transpose(braco2)
braco2 = np.vstack([braco2, np.ones(np.size(braco2,1))])

baseBraco2 = np.array([1, -27.5, 26, 1])

cabeca = np.array([
                   [-4, -30, 28],
                   [-4, -25, 28],
                   [-11, -25, 28],
                   [-11, -30, 28],
                   [-4, -30, 28],
                   [-4, -30, 35],
                   [-4, -25, 35],
                   [-4, -25, 28],
                   [-4, -25, 35],
                   [-11, -25, 35],
                   [-11, -25, 28],
                   [-11, -25, 35],
                   [-11, -30, 35],
                   [-11, -30, 28],
                   [-11, -30, 35],
                   [-4, -30, 35] 
])
cabeca = np.transpose(cabeca)
cabeca = np.vstack([cabeca, np.ones(np.size(cabeca,1))])

baseCabeca = np.array([-7.5, -27.5, 28, 1])

# criando a pessoa com a classe
Pessoa = Pessoa(pessoa, centro, braco2, baseBraco2, cabeca, baseCabeca)

# criando pontos para o objeto nuvem
nuvem = np.array([
                  [50,0,100], 
                  [50,0,105],
                  [50,0,100],
                  [50,20,100], 
                  [50,20,105],
                  [50,20,100],
                  [100,20,100], 
                  [100,20,105],
                  [100,20,100],
                  [100,0,100], 
                  [100,0,105],
                  [100,0,100],
                  [50,0,100],
                  [50,0,105],
                  [50,20,105],
                  [100,20,105],
                  [100,0,105],
                  [50,0,105]
])

nuvem = np.transpose(nuvem)
nuvem = np.vstack([nuvem, np.ones(np.size(nuvem,1))])
Nuvem = Nuvem(nuvem)

a=180
b=5
c=120

paraquedas = np.array([
                       [a,b,c],
                       [a,b-20,c+30],
                       [a,b+5,c+40],
                       [a,b+30,c+30],
                       [a+5,b+25,c+25],
                       [a+10,b+5,c+35],
                       [a,b+5,c+40],
                       [a+10,b+5,c+35],
                       [a+5,b-25,c+25],
                       [a,b-20,c+30],
                       [a-5,b-25,c+25],
                       [a-10,b+5,c+35],
                       [a,b+5,c+40],
                       [a-10,b+5,c+35],
                       [a-5,b+25,c+25],
                       [a,b+30,c+30],
                       [a,b+10,c]
])

paraquedas = np.transpose(paraquedas)
paraquedas = np.vstack([paraquedas, np.ones(np.size(paraquedas,1))])

centroParaquedas = np.array([a,b+5,c, 1])
Paraquedas = Paraquedas(paraquedas, centroParaquedas)

# setando a figura e o eixo que queremos plotar
fig = plt.figure(figsize=(10,10))
ax0 = plt.axes(projection='3d')
plt.close()

# configurando os eixos
ax0.set_xlim3d((-50, 50))
ax0.set_xlabel("Eixo X")
ax0.set_ylim3d((-50, 50))
ax0.set_ylabel("Eixo Y")
ax0.set_zlim3d((-50, 50))
ax0.set_zlabel("Eixo Z")


# listando os objetos a serem desenhados
obj1, = ax0.plot3D([], [], [], lw=2, color='#000000') # plataforma
obj2, = ax0.plot3D([], [], [], lw=2, color='#0000FF') # foguete
obj3, = ax0.plot3D([], [], [], lw=2, color='#0000FF') # base do foguete
obj4, = ax0.plot3D([], [], [], lw=2, color='#0000FF') # ponta do foguete
obj5, = ax0.plot3D([], [], [], lw=2, color='#FF7F00') # pessoa
obj6, = ax0.plot3D([], [], [], lw=2, color='#FF7F00') # braço 2 da pessoa
obj7, = ax0.plot3D([], [], [], lw=2, color='#FF7F00') # cabeca da pessoa
obj8, = ax0.plot3D([], [], [], lw=2, color='#008000') # segunda plataforma
obj9, = ax0.plot3D([], [], [], lw=2, color='#FF7F00') # paraquedas
obj10, = ax0.plot3D([], [], [], '--', lw=1, color='#000') # nuvem 1
obj11, = ax0.plot3D([], [], [], '--', lw=1, color='#000') # nuvem 2
obj12, = ax0.plot3D([], [], [], '--', lw=1, color='#000') # nuvem 3



############################### ANIMAÇÃO ###################################################################
def init():
    # setando quais pontos de cada objeto serão desenhados 

    obj1.set_data(Plataforma_1.pontos[0,:], Plataforma_1.pontos[1,:])
    obj1.set_3d_properties(Plataforma_1.pontos[2,:])

    obj2.set_data(Foguete.pontos[0,:], Foguete.pontos[1,:])
    obj2.set_3d_properties(Foguete.pontos[2,:])

    obj3.set_data(Foguete.base[0,:], Foguete.base[1,:])
    obj3.set_3d_properties(Foguete.base[2,:])

    obj4.set_data(Foguete.ponta[0,:], Foguete.ponta[1,:])
    obj4.set_3d_properties(Foguete.ponta[2,:])

    obj5.set_data(Pessoa.pontos[0,:], Pessoa.pontos[1,:])
    obj5.set_3d_properties(Pessoa.pontos[2,:])

    obj6.set_data(Pessoa.braco2[0,:], Pessoa.braco2[1,:])
    obj6.set_3d_properties(Pessoa.braco2[2,:])

    obj7.set_data(Pessoa.cabeca[0,:], Pessoa.cabeca[1,:])
    obj7.set_3d_properties(Pessoa.cabeca[2,:])

    # obj8.set_data(Plataforma_2.pontos[0,:], Plataforma_2.pontos[1,:])
    # obj8.set_3d_properties(Plataforma_2.pontos[2,:])

    obj10.set_data(Nuvem.pontos[0,:], Nuvem.pontos[1,:])
    obj10.set_3d_properties(Nuvem.pontos[2,:])

    pontosNuvem = trans3D(-100, 40, 50) @ Nuvem.pontos
    obj11.set_data(pontosNuvem[0,:], pontosNuvem[1,:])
    obj11.set_3d_properties(pontosNuvem[2,:])

    pontosNuvem = trans3D(-100, -30, 30) @ Nuvem.pontos
    obj12.set_data(pontosNuvem[0,:], pontosNuvem[1,:])
    obj12.set_3d_properties(pontosNuvem[2,:])


    # ajustando pontos do paraquedas (antes de desenha-lo na tela)
    # isso é por que o objeto precisa estar em uma escala pequeninissima no começo
    S = trans3D(Paraquedas.centro[0], Paraquedas.centro[1], Paraquedas.centro[2]) \
    @ scale3D(0.1,0.1,0.1) \
    @ trans3D(-Paraquedas.centro[0], -Paraquedas.centro[1], -Paraquedas.centro[2])
    Paraquedas.pontos = S @ Paraquedas.pontos

    # ajustando pontos da plataforma (antes de desenhala na tela)
    # isso é por que o objeto esta sendo reaproveitado da primeira plataforma
    Plataforma_2.pontos = trans3D(85,0,0) @ Plataforma_2.pontos
    Plataforma_2.centro = trans3D(85,0,0) @ Plataforma_2.centro
    
    return (obj1, obj2, obj3, obj4, obj5, obj6, obj7,)


# função que faz a animação (chamada sequencialmente)
def animate(i):

    if i < 50: 
        # pessoa acenando para o foguete
        if i < 15:
            # criando a matriz transformação que roda o braço em relação a sua base
            M = trans3D(Pessoa.baseBraco2[0], Pessoa.baseBraco2[1], Pessoa.baseBraco2[2]) \
            @ rot3D(-10, 'y') \
            @ trans3D(-Pessoa.baseBraco2[0], -Pessoa.baseBraco2[1], -Pessoa.baseBraco2[2])
            # aplicando a matriz M no braço 2 da pessoa
            Pessoa.braco2 = M @ Pessoa.braco2

            # criando a matriz transformação que roda a cabeça em relação a sua base
            M = trans3D(Pessoa.baseCabeca[0], Pessoa.baseCabeca[1], Pessoa.baseCabeca[2]) \
            @ rot3D(-2, 'z') \
            @ trans3D(-Pessoa.baseCabeca[0], -Pessoa.baseCabeca[1], -Pessoa.baseCabeca[2])
            # aplicando a matriz M na cabeça da pessoa
            Pessoa.cabeca = M @ Pessoa.cabeca

        elif i < 18:
            M = trans3D(Pessoa.baseBraco2[0], Pessoa.baseBraco2[1], Pessoa.baseBraco2[2]) \
            @ rot3D(15, 'y') \
            @ trans3D(-Pessoa.baseBraco2[0], -Pessoa.baseBraco2[1], -Pessoa.baseBraco2[2])
            Pessoa.braco2 = M @ Pessoa.braco2
        elif i < 21:
            M = trans3D(Pessoa.baseBraco2[0], Pessoa.baseBraco2[1], Pessoa.baseBraco2[2]) \
            @ rot3D(-15, 'y') \
            @ trans3D(-Pessoa.baseBraco2[0], -Pessoa.baseBraco2[1], -Pessoa.baseBraco2[2])
            Pessoa.braco2 = M @ Pessoa.braco2
        elif i < 24:
            M = trans3D(Pessoa.baseBraco2[0], Pessoa.baseBraco2[1], Pessoa.baseBraco2[2]) \
            @ rot3D(15, 'y') \
            @ trans3D(-Pessoa.baseBraco2[0], -Pessoa.baseBraco2[1], -Pessoa.baseBraco2[2])
            Pessoa.braco2 = M @ Pessoa.braco2
        elif i < 28:
            M = trans3D(Pessoa.baseBraco2[0], Pessoa.baseBraco2[1], Pessoa.baseBraco2[2]) \
            @ rot3D(-15, 'y') \
            @ trans3D(-Pessoa.baseBraco2[0], -Pessoa.baseBraco2[1], -Pessoa.baseBraco2[2])
            Pessoa.braco2 = M @ Pessoa.braco2
        elif i < 31:
            M = trans3D(Pessoa.baseBraco2[0], Pessoa.baseBraco2[1], Pessoa.baseBraco2[2]) \
            @ rot3D(15, 'y') \
            @ trans3D(-Pessoa.baseBraco2[0], -Pessoa.baseBraco2[1], -Pessoa.baseBraco2[2])
            Pessoa.braco2 = M @ Pessoa.braco2
        elif i < 34:
            M = trans3D(Pessoa.baseBraco2[0], Pessoa.baseBraco2[1], Pessoa.baseBraco2[2]) \
            @ rot3D(-15, 'y') \
            @ trans3D(-Pessoa.baseBraco2[0], -Pessoa.baseBraco2[1], -Pessoa.baseBraco2[2])
            Pessoa.braco2 = M @ Pessoa.braco2
        elif i < 42:
            M = trans3D(Pessoa.baseBraco2[0], Pessoa.baseBraco2[1], Pessoa.baseBraco2[2]) \
            @ rot3D(20, 'y') \
            @ trans3D(-Pessoa.baseBraco2[0], -Pessoa.baseBraco2[1], -Pessoa.baseBraco2[2])
            Pessoa.braco2 = M @ Pessoa.braco2
        


        # movimento inicial da câmera para mostrar o foguete
        ax0.view_init(elev=40-(0.6*i),azim=70-(1.2*i))

    elif i < 100: # decolagem
        # criando a matriz transformação que translada 2 no sentido positivo de z
        M = trans3D(Foguete.centro[0], Foguete.centro[1], Foguete.centro[2]) \
        @ trans3D(0, 0, 2) \
        @ trans3D(-Foguete.centro[0], -Foguete.centro[1], -Foguete.centro[2])
        # aplicando a matriz M nos pontos do foguete
        Foguete.pontos = M @ Foguete.pontos
        Foguete.centro = M @ Foguete.centro
        Foguete.base = M @ Foguete.base
        Foguete.ponta = M @ Foguete.ponta
        Foguete.basePonta = M @ Foguete.basePonta
        Foguete.baseCentro = M @ Foguete.baseCentro

        if i < 105:
            # criando a matriz transformação que roda a cabeça pra cima em relação a sua base
            M = trans3D(Pessoa.baseCabeca[0], Pessoa.baseCabeca[1], Pessoa.baseCabeca[2]) \
            @ rot3D(2, 'x') \
            @ trans3D(-Pessoa.baseCabeca[0], -Pessoa.baseCabeca[1], -Pessoa.baseCabeca[2])
            # aplicando a matriz M nos pontos da pessoa
            Pessoa.cabeca = M @ Pessoa.cabeca
    
        # criando a matriz transformação que diminui a pessoa
        M = trans3D(Pessoa.centro[0], Pessoa.centro[1], Pessoa.centro[2]) \
        @ scale3D(0.98, 0.98, 0.98) \
        @ trans3D(-Pessoa.centro[0], -Pessoa.centro[1], -Pessoa.centro[2])
        # aplicando a matriz M nos pontos da pessoa
        Pessoa.pontos = M @ Pessoa.pontos
        Pessoa.centro = M @ Pessoa.centro
        Pessoa.braco2 = M @ Pessoa.braco2
        Pessoa.baseBraco2 = M @ Pessoa.baseBraco2
        Pessoa.cabeca = M @ Pessoa.cabeca
        Pessoa.baseCabeca = M @ Pessoa.baseCabeca
        
        # criando a matriz transformação que diminui a plataforma_1
        M = trans3D(Plataforma_1.centro[0], Plataforma_1.centro[1], Plataforma_1.centro[2]) \
        @ scale3D(0.98, 0.98, 0.98) \
        @ trans3D(-Plataforma_1.centro[0], -Plataforma_1.centro[1], -Plataforma_1.centro[2])
        # aplicando a matriz M nos pontos da plataforma_1
        Plataforma_1.pontos = M @ Plataforma_1.pontos
        Plataforma_1.centro = M @ Plataforma_1.centro

        # mudando os limites do eixo z (acompanhar a subida)
        ax0.set_zlim3d((-50+2*(i-49), 50+2*(i-49)))

        # rotacionando a camera envolta do foguete enquanto sobre
        ax0.view_init(elev=10.6,azim=11.2-(i-49))

    elif i < 110: # giro ao chegar no alto
        # criando a matriz rotação que roda o foguete em torno de y
        M = trans3D(Foguete.centro[0], Foguete.centro[1], Foguete.centro[2]) \
        @ rot3D(9,'y') \
        @ trans3D(-Foguete.centro[0], -Foguete.centro[1], -Foguete.centro[2])
        # aplicando a matriz M nos pontos do foguete
        Foguete.pontos = M @ Foguete.pontos
        Foguete.centro = M @ Foguete.centro
        Foguete.base = M @ Foguete.base
        Foguete.baseCentro = M @ Foguete.baseCentro
        Foguete.ponta = M @ Foguete.ponta
        Foguete.basePonta = M @ Foguete.basePonta

        # rotacionando a camera envolta do foguete enquanto roda
        ax0.view_init(elev=10.6,azim=-37.8-(i-99))

    elif i < 150: # desacoplagem da base do foguete la no alto 
        # criando a matriz que roda o foguete no sentido de x e translada também em x
        M = trans3D(Foguete.centro[0], Foguete.centro[1], Foguete.centro[2]) \
        @ rot3D(9,'x') @ trans3D(3, 0, 0) \
        @ trans3D(-Foguete.centro[0], -Foguete.centro[1], -Foguete.centro[2])
        # aplicando a matriz M nos pontos do foguete
        Foguete.pontos = M @ Foguete.pontos
        Foguete.centro = M @ Foguete.centro
        Foguete.ponta = M @ Foguete.ponta
        Foguete.basePonta = M @ Foguete.basePonta

        # mudando os limites do eixo x (acompanhar o movimento pra frente)
        ax0.set_xlim3d((-50+2*(i-109), 50+2*(i-109)))

        # adicionando o efeito de escala na base desacoplada do foguete 
        S = trans3D(Foguete.baseCentro[0], Foguete.baseCentro[1], Foguete.baseCentro[2]) \
        @ scale3D(0.99, 0.99, 0.99) @ rot3D(45, 'y') \
        @ trans3D(-Foguete.baseCentro[0], -Foguete.baseCentro[1], -Foguete.baseCentro[2])

        # aplicando a matriz M na base do foguete
        Foguete.base = S @ Foguete.base

    elif i<200: # centralizando o foguete em voo horizontal
      # criando a matriz que roda o foguete no sentido de x e translada também em x
      M = trans3D(Foguete.centro[0], Foguete.centro[1], Foguete.centro[2]) \
      @ rot3D(9,'x') @ trans3D(1, 0, 0) \
      @ trans3D(-Foguete.centro[0], -Foguete.centro[1], -Foguete.centro[2])
      # aplicando a matriz M nos pontos do foguete
      Foguete.pontos = M @ Foguete.pontos
      Foguete.centro = M @ Foguete.centro
      Foguete.ponta = M @ Foguete.ponta
      Foguete.basePonta = M @ Foguete.basePonta

      # mudando os limites do eixo x (acompanhar o movimento pra frente)
      ax0.set_xlim3d((-50+2*(i-109), 50+2*(i-109)))


    elif i < 210: # volta pra posição reta
        # criando a matriz que roda o foguete no sentido de x e translada também em x
        M = trans3D(Foguete.centro[0], Foguete.centro[1], Foguete.centro[2]) \
        @ rot3D(-9,'y') \
        @ trans3D(-Foguete.centro[0], -Foguete.centro[1], -Foguete.centro[2])
        # aplicando a matriz M nos pontos do foguete
        Foguete.pontos = M @ Foguete.pontos
        Foguete.centro = M @ Foguete.centro
        Foguete.ponta = M @ Foguete.ponta
        Foguete.basePonta = M @ Foguete.basePonta

        # rotacionando a camera envolta do foguete enquanto se move
        # ax0.view_init(elev=10.6,azim=-52.8-1.5*(i-150))

        # mudando os limites do eixo x (acompanhar o movimento pra frente)
        # ax0.set_xlim3d((40+2*(i-149), 120+3*(i-149)))


    elif i < 270: # pousando
      if i < 220: # abrindo a ponta do foguete 
          # criando a matriz transformação que rotaciona a ponta do foguete en volta de sua base
          M = trans3D(Foguete.basePonta[0], Foguete.basePonta[1], Foguete.basePonta[2]) \
          @ rot3D(15, 'x') \
          @ trans3D(-Foguete.basePonta[0], -Foguete.basePonta[1], -Foguete.basePonta[2])
          # aplicando a matriz M na ponta do foguete
          Foguete.ponta = M @ Foguete.ponta
          Foguete.basePonta = M @ Foguete.basePonta

          # escalando o paraquedas para tamanho normal
          S = trans3D(Paraquedas.centro[0], Paraquedas.centro[1], Paraquedas.centro[2]) \
          @ scale3D(1.6,1.6,1.6) \
          @ trans3D(-Paraquedas.centro[0], -Paraquedas.centro[1], -Paraquedas.centro[2])
          
          Paraquedas.pontos = S @ Paraquedas.pontos
          
      else:
          # criando a matriz transformação que translada o foguete no sentido negativo de z
          M = trans3D(Foguete.centro[0], Foguete.centro[1], Foguete.centro[2]) \
          @ trans3D(0, 0, -2) \
          @ trans3D(-Foguete.centro[0], -Foguete.centro[1], -Foguete.centro[2])
          
          # aplicando a matriz M nos pontos do foguete
          Foguete.pontos = M @ Foguete.pontos
          Foguete.centro = M @ Foguete.centro
          Foguete.ponta = M @ Foguete.ponta
          Foguete.basePonta = M @ Foguete.basePonta

          # aplicando a matriz M nos pontos do paraquedas
          Paraquedas.pontos = M @ Paraquedas.pontos
          Paraquedas.centro = M @ Paraquedas.centro

          # mudando os limites do eixo z (acompanhar a descida)
          ax0.set_zlim3d((50-(i-210),150-(i-210)))

    elif i<450:

      if i < 280: # fechando a ponta do foguete
        # criando a matriz transformação que rotaciona a ponta do foguete en volta de sua base
        M = trans3D(Foguete.basePonta[0], Foguete.basePonta[1], Foguete.basePonta[2]) \
        @ rot3D(-15, 'x') \
        @ trans3D(-Foguete.basePonta[0], -Foguete.basePonta[1], -Foguete.basePonta[2])
        
        # aplicando a matriz M na ponta do foguete
        Foguete.ponta = M @ Foguete.ponta
        Foguete.basePonta = M @ Foguete.basePonta

      # diminuindo o paraquedas apos a aterrisagem
      S = trans3D(Paraquedas.centro[0], Paraquedas.centro[1], Paraquedas.centro[2]) \
      @ scale3D(0.6,0.6,0.6) \
      @ trans3D(-Paraquedas.centro[0], -Paraquedas.centro[1], -Paraquedas.centro[2])
      
      Paraquedas.pontos = S @ Paraquedas.pontos

    # atualizando os objetos com os novos pontos

    obj1.set_data(Plataforma_1.pontos[0,:], Plataforma_1.pontos[1,:])
    obj1.set_3d_properties(Plataforma_1.pontos[2,:])

    obj2.set_data(Foguete.pontos[0,:], Foguete.pontos[1,:])
    obj2.set_3d_properties(Foguete.pontos[2,:])

    obj3.set_data(Foguete.base[0,:], Foguete.base[1,:])
    obj3.set_3d_properties(Foguete.base[2,:])

    obj4.set_data(Foguete.ponta[0,:], Foguete.ponta[1,:])
    obj4.set_3d_properties(Foguete.ponta[2,:])

    obj5.set_data(Pessoa.pontos[0,:], Pessoa.pontos[1,:])
    obj5.set_3d_properties(Pessoa.pontos[2,:])

    obj6.set_data(Pessoa.braco2[0,:], Pessoa.braco2[1,:])
    obj6.set_3d_properties(Pessoa.braco2[2,:])

    obj7.set_data(Pessoa.cabeca[0,:], Pessoa.cabeca[1,:])
    obj7.set_3d_properties(Pessoa.cabeca[2,:])
    
    vazio = np.array([0,0,0,0])

    if i>90:
      # limpando a pessoa e a plataforma de decolagem depois que saem da visao
      obj1.set_data(vazio,vazio)
      obj1.set_3d_properties(vazio)
      
      obj5.set_data(vazio,vazio)
      obj5.set_3d_properties(vazio)

      obj6.set_data(vazio,vazio)
      obj6.set_3d_properties(vazio)

      obj7.set_data(vazio,vazio)
      obj7.set_3d_properties(vazio)

    if i>200:
      # limpando a base desacoplada do foguete
      obj3.set_data(vazio,vazio)
      obj3.set_3d_properties(vazio)

      obj10.set_data(vazio,vazio)
      obj10.set_3d_properties(vazio)

      obj11.set_data(vazio,vazio)
      obj11.set_3d_properties(vazio)

      obj12.set_data(vazio,vazio)
      obj12.set_3d_properties(vazio)

    if i > 209:
      obj9.set_data(Paraquedas.pontos[0,:], Paraquedas.pontos[1,:])
      obj9.set_3d_properties(Paraquedas.pontos[2,:])

    if i > 210:
      # girando a camera para aterrisagem
      ax0.view_init(elev=10.6,azim=-50-(i-210))
      obj8.set_data(Plataforma_2.pontos[0,:], Plataforma_2.pontos[1,:])
      obj8.set_3d_properties(Plataforma_2.pontos[2,:])

    return (obj1, obj2, obj3, obj4, obj5, obj6, obj7,)


# fazendo a animação em si
anim = animation.FuncAnimation(fig, animate, init_func=init, frames=350, interval=50, blit=True)

# pra fazer funcionar no colab
rc('animation', html='jshtml')
rcParams['animation.embed_limit'] = 30
anim # chmando a animação
